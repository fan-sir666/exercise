# 周考_20210416

> ###### 共25题，一题4分，不需要借助任何编辑/译器，
>
> PS：诚信考试，自觉遵守，录屏考



##### 1、TS 和 JS 有什么区别？

```typescript
Ts ：提供了 静态类型 和 面相对象的编程思想 javaScript集群使项目代码更易维护 基础了泛型 接口
js ： 弱语言 动态创建网页 
```

##### 2、TS 有哪些基础类型？

```typescript
number string boolean undefined null any Unkonwn void never enum 元组 数组 函数 对象 
```

##### 3、如何将TS文件编译成JS？ 

```typescript
配置 js 文件输出路径 ，执行 tsc -w 监听自动生成js 文件
```

##### 4、请不借助编译器将下面的TS代码转ES5

```typescript
// TS代码
let flag: boolean = false;
let num: number = 10;
let str: string = "老王";
let arr: number[] = [1, 2, 3];
let list: Array<number> = [1, 2, 3];
```

```js
// 对应的ES5代码：
var flag = false；
var num = 10；
var str = "老王"
var arr = [1,2,3];
var list = [1,2,3];

```

##### 5、你知道数字枚举吗？(一)

```typescript
/* 阅读代码，输出结果 */
enum Direction {
  NORTH,
  SOUTH,
  EAST = 6,
  WEST,
}
// 将结果填入[]当中
console.log(Direction.NORTH) //输出：[0] 
console.log(Direction.SOUTH) //输出：[1]
console.log(Direction.WEST) //输出：[7]
```

##### 6、你知道数字枚举吗？(二)

```typescript
/* 阅读代码，输出结果 */
enum Direction {
  NORTH,
  SOUTH,
  EAST = 0,
  WEST,
}

// 将结果填入[]当中
console.log(Direction.EAST) //输出：[0]
console.log(Direction.WEST)//输出：[1]
console.log(Direction[0]) //输出：[EAST]
console.log(Direction[1]) //输出：[WEST]
```

##### 7、你知道字符串枚举吗？

```typescript
/* 阅读代码，输出结果 */
enum Direction {
  NORTH = "NORTH",
  SOUTH = "SOUTH",
  EAST = "EAST",
  WEST = "WEST",
}
// 将结果填入[]当中
console.log(Direction.NORTH) //输出：[NORTH]
console.log(Direction.SOUTH) //输出：[SOUTH]
console.log(Direction.EAST) //输出：[EAST]
console.log(Direction.WEST) //输出：[WEST]
```

##### 8、你知道异构枚举吗？(一)

```typescript
/* 阅读代码，输出结果 */
enum Enum {
  A,
  B,
  C = "C",
  D = "D",
  E = 8,
  F,
}
// 将结果填入[]当中
console.log(Enum.A) //输出：[0]
console.log(Enum.D) //输出：[D]
console.log(Enum.F) //输出：[9]
```

##### 9、你知道异构枚举吗？(二)

```typescript
/* 阅读代码，输出结果 */
enum Enum {
  A,
  B,
  C = "C",
  D = "D",
  E = 1,
  F = "F",
}
// 将结果填入[]当中
console.log(Enum.A) //输出：[0]
console.log(Enum.F) //输出：[F]
console.log(Enum[0]) //输出：[A]
console.log(Enum[1]) //输出：[E]
```

##### 10、**你知道异构枚举吗？(三)**

```typescript
// 观察下面代码，有什么问题吗？如果有，请概括说明原因
enum Enum {
  A = 1,
  B = "B",
  C = 2,
  D = "D",
  E,
}

// 答: 
问题: 编译器会在E下面报错（划红线）
原因: 枚举成员必须具有初始化表达式。当某成员的前一个成员是number类型，那么该成员的值会根据前一个成员的数值自动+1，例:{D=10,E,} 那么E的值就是11。但如果前一个成员是string类型，那么其下个成员需要手动赋值无法自动初始化值，例:{D='D',E,}会报错 
```

##### 11、**说说你对Any类型的理解**

```js
1.any类型是类型系统的顶级类型，也被称作全局超级类型
2.any类型的要求十分宽松自由，即任意类型值均可赋值
3.如果使用any类型，就无法使用ts提供的大量的保护机制，实时查看代码编写时的错误
4.使用any类型，就很容易编写出类型正确但在运行时有问题的代码
```

##### 12、Unkonwn相比Any类型，有什么优势？

```typescript
1.Unknown类型就是TypeScirpt官方为了解决any类型带来的问题，所引入一种类型
2.any类型可以赋值给大多类型，unkonw只能赋值给any类型和unkonw类型自身
3.对于any类型ts无需事先执行任何形式的检查，但unknown会进行检查，禁止任何更改

// 例：[参考]
let value: any; // 赋值为any类型的情况
value.foo.bar; // OK
value.trim(); // OK
value(); // OK
new value(); // OK
value[0][1]; // OK

let value: unknown; // 赋值为unknown类型的情况
value.foo.bar; // Error
value.trim(); // Error
value(); // Error
new value(); // Error
value[0][1]; // Error
```

##### 13、**说说Never类型的应用场景**

```typescript
1.应用于总是抛出异常的情况
2.应用于永远不会有返回值的函数（函数不是void类型）
3.使用never，目的就是写出类型绝对安全的代码
```

##### 14、**说说类型断言有哪两种形式？你更推荐使用哪种**

```typescript
1.尖括号语法形式：<type>变量
2.as语法形式：变量 as type
3.更推荐使用：as语法

理由：在 JSX/TSX 中使用尖括号的断言语法时，该语法会存在歧义
     如:在 TSX 中尖括号除了表示类型断言外，还可能表示一个泛型 
```

##### 15、类型断言和类型转换一样吗？说说你的理解

```typescript
1.类型断言只会影响 TS 编译时的类型，通过断言这种方式告诉编译器“我知道这里在做什么”
2.类型断言和类型转换不一样，类型断言不会真的影响到变量的类型，类型转换会实际影响到变量的类型
```

##### 16、非空断言 or 确定赋值断言？(一)

```typescript
// 阅读下面代码，回答问题
let x!: number;
init();
console.log(x+1);

function init() {
    x = 10;
}

// 问：上面的代码需要使用哪种断言，如何使用？
// 答：确定赋值断言  要告诉编译器 我指定会赋值的 你先给我通过编译不要报错

```

##### 17、非空断言 or 确定赋值断言？(二)

```typescript
// 阅读下面代码，回答问题
let x!: number;
init();
console.log(x);

function init() {
    x = 10;
}

// 问：上面的代码需不需要使用断言？如果需要，需要使用哪种，如何使用？
// 答：确定赋值断言  要告诉编译器 我指定会赋值的 你先给我通过编译不要报错

```

##### 18、非空断言 or 确定赋值断言？(三)

```typescript
function fun(param: string | undefined | null) {
  const str: string = param!;
}

// 问：上面的代码需要使用哪种断言，如何使用？
// 答：非空断言  直接排除 undefined 或 null 的情况

```

##### 19、非空断言 or 确定赋值断言？(四)

```typescript
type NumGenerator = () => number;

function myFunc(numGenerator: NumGenerator | undefined) {
  const num = numGenerator!();
}

// 问：上面的代码需要使用哪种断言，如何使用？
// 答：非空断言  直接排除 undefined的情况

```

##### 20、**类型守卫有哪些关键字可使用？简述一下作用**

```typescript
1.in 关键字：检查一个对象上是否存在一个属性
2.typeof 关键字：检测判断变量的类型
3.instanceof 关键字：检测某个实例对象的原型链上是否存在某构造函数的`prototype`属性
```

##### 21、根据要求，不借助编译器写代码

```typescript
/*
  1.使用类型别名声明一个 Types 类型变量，含有number、string、boolean类型
  2.定义一个foo函数，确认该函数有返回值且类型为boolean，接收 param参数，参数类型为 Types
  3.函数内，借助类型守卫：如果param是number返回true，如果param是string返回false，如果param是boolean  返回param
  4.思考并给出代码：如果 param不是 Types类型，需要如何处理一番?
*/

// 请手撕代码：
type Types = number | string | boolean
let foo = (param:Types):boolean=>{
    if (typeof param === "number"){
        return true
    } else if (typeof param === "string"){
        return false
    } else if (typeof param === "boolean"){
        return param
    }else {
        // 4. 抛出错误的函数
        throw new Error(param); // 方式一
        //返回never类型，代表该函数始终无返回
        return param; // 方式二
    }
    
}



```

##### 22、你知道可选参数吗？

```typescript
// 观察下面的代码，有哪些问题呢？给出解释
function sum(a?: number, b: number):void {
  console.log(a + b);
}

1.必选参数不能置于可选参数之后，即为：function sum(a: number, b?: number){}
2.在本题已知有可选参数的情况下，即可能传入该参数也可能不传入该参数，那么该参数就有undefined的情况，所以就需要对 console.log(a + b) 进行类型守卫等合理的处理

```

##### 23、根据要求，不借助编译器写代码

```typescript
/* 
   写一个 getNum方法：
   接收不定数量的number类型的参数，要求用100依次减去接收的number参数，求出结果（方法返回值要求为number）
   注：如果传入的参数数量为0时，要求返回999
*/

// 手撕代码：
getNum(...number):number{
    if(number.length == 0) return 999;
    let num = 100;
    for (let i = 0; i < rest.length; i++) {
        num -= rest[i];
    }
    return num;
}

```

##### 24、你知道类的继承吗？

```typescript
// 代码实现：定义父类Father，让子类Son继承父类Father（无需成员）
class Father{}
class Son extends Father{}

```

##### 25、类的修饰符有哪些？简述说明一下

```typescript
1.public 公共修饰符：任何地方均可使用，默认所有的属性和方法都是public的
2.private 私有修饰符：只能在自身类中使用
3.protected 受保护的修饰符：相比private，允许继承后在子类中使用
4.readonly 只读修饰符：必须在声明时或构造函数里被初始化，且不可修改
```










































































