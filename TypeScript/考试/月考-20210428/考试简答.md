# 知识点

## 1.ts的类型，元素&数组的定义

```typescript
string 字符串 boolean 布尔 number 数字 void null undefined array enum tuple any Never
    
let arr:number[] = [1,2,3]
let arrTuple:[string,number,boolean]
arrTuple:["dsa",1,true]
```

## 2.ts枚举分为几种

```typescript
//数字型

enum numEnum {
    num1,
    num2,
    num3
}

// 字符串型
enum strEnum {
    str1="张三",
    str2="李四",
    str3="王五"
}

// 异构枚举
enum ygEnum {
    man,
    woman="女",
    renyao="人妖"
}


```

## 3.ts类型断言

```
1. 尖括号语法:<type>变量
2. as语法: 变量 as type

不推荐尖括号语法，在TSX中除了可以表示类型断言，也是泛型的表示，语法上存在歧义。
```

## 4. 类型断言和类型转换的区别

```
类型转换: 将一种类型转换为另一种类型，在运行时数据类型发生改变
类型断言: 只是一种让编译器通过一种手段，数据还是原有类型
```

## 5.函数的定义

```
function sum(x:number,y:number):number{
	return x+y
}
function sum(x:number,y?:number):number{
	return x+y
}
function sum(x:number,y:number = 6):number{
	return x+y
}
function sum(...rest:number[]):number{
	rest.forEach(item=>console.log(item))
}
```

## 6. 类型保护的作用，有哪些关键字

```
// 类型保护
一种类型检查的方式，用于确保该类型在一定的范围内

类型保护关键字: in  typeof   instanceof
```

## 7. ts 类的继承 和 类实现接口

```typescript
// 继承
class 子类 extends 父类 {}
// 类实现接口
class 类名 implements 接口名 {}

// 注意点:
1.子类和接口都可以继承类。接口一旦继承某个类，就会继承该类的所有属性和方法，但只是继承了属性和方法的声明，不会继承实现。
2. 如果接口继承的类中包含 protected 的属性和方法，那么就只有这个类的子类才能实现这个接口。
3. 子类想要调用父类的方法，就必须使用super关键字，该关键字用来访问和调用一个对象的父对象上的函数。
```

## 接口的继承注意点

```
接口也可以继承接口，或继承多个接口
接口继承后  ，定义同名属性时类型必须一致
```



## 8.类的修饰符

```
1. public公共修饰符：任何地方都可以使用，默认所有的属性和方法都是public的
2.private 私有修饰符：只能在自身类中使用
3.protected 受保护的修饰符：相比private，允许继承后在子类中使用
4.readonly 只读修饰符: 必须在声明时或构造函数里初始化,且不可更改
```

## 9.接口interface 和 类型别名 type的区别 及 使用语法 ，如何扩展？



```typescript
// 接口 interface: 用来描述对象或者类的具体结构，约束他们的行为 ，使用继承extends扩展
interface IPerson {
    name:string;
    (num1:number,num2:number):number;
}
// 类型别名 type： 为类型起一个新名字来引用哪个类型，使用&交叉符扩展
type XXX = string | number


```

## 10.泛型的特点、作用

```typescript
ts为了让健壮的代码，同时也具有灵活性和可重用性，推出了泛型
class XXX<T> {
    private arr:T[] = [];
    push = (item:T) => this.arr.push(item)
}
```

## 11.ts和js的不同

```
1. 文件后缀名不同   .ts   .js
2. ts 支持强类型和静态类型
3. ts 编译时报错，js运行时报错
4. ts 支持es6 模块、泛型、接口
```

## 12 交叉类型和联合类型

```typescript
// 交叉类型  &
type PointX = { x: number; };
type PointXY = PointX & { y: number; };

// 联合类型 |
let val:string|number

```



## 13.常量枚举和普通枚举的区别

```
常量枚举: 不会生成真实存在的对象，而是利用枚举成员的值直接替换使用到的地方
普通枚举：编译之后是一个真实的存储对象

区别：常量枚举会在编译阶段被删除，并且不能包含计算成员
```

## 14ES6模块化和commonJS模块化 相同点

```
// Es6模块化
1. 一次性导入导出
export {xx,yy,zz}
import {xx,yy,zz} from "path"
2. 分开导入导出
export XX
import {XX} from "path"
3. 默认导入导出
export default XXX;
import XXX from "path"

// commonJS模块化
exports = {}
let xxx = require("path")

// 相同点
1. 隔离不同的js文件，仅暴露当前模块所需要的其他模块
2. 都可以添加属性，但不可以对引入的对象内部属性的值进行修改
```

## 15.抽象类和普通类的区别

```
1. 普通类可以被实例化，抽象类不允许被实例化
2. 继承时，对于抽象类要求抽象方法必须被子类实现
```



## 16.装饰器的使用步骤

```typescript
1. 声明装饰器函数
function text(target:any){
    clg("hello word");
}
2. 使用装饰器 @ 起到调用装饰器函数的作用 可以运用在 类声明、属性、访问符、方法或方法参数上。
class textClass {
    @text
    name:string = "dsa";
    @text
    study(@text a:number){}
    constructor(){
        clg("我是构造函数")
    }
}
执行原理:1.由上至下依次对装饰器表达式求值  2.求值的结果会被当作函数，由下至上依次调用
```



## 17.ts的优点

```
1. ts 增强了代码的可读性和可维护性。
2. ts 是js的超集，.js文件可直接重命名为.ts文件
3. 强大的类型系统、不显示的定义类型也会自动做出类型推论。
4. ts编译时报错，提高开发效率，兼容第三方库，第三方库即使不是ts写的，也可以编写单独类型文件供ts读取。
5. 支持ES6的所有特点、支持泛型、接口等等
```

